1.【两数之和】
    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
    示例:
    给定 nums = [2, 7, 11, 15], target = 9；
    因为 nums[0] + nums[1] = 2 + 7 = 9；
    所以返回 [0, 1]。
2. 【两数相加】
    给出两个 非空 的链表用来表示两个非负的整数。
    其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
    如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
    您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
    示例：
    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
    输出：7 -> 0 -> 8
    原因：342 + 465 = 807
3. 【无重复字符的最长子串】
    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
    示例 1:
        输入: "abcabcbb"
        输出: 3
        解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
    示例 2:
        输入: "bbbbb"
        输出: 1
        解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
    示例 3:
        输入: "pwwkew"
        输出: 3
        解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
             请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
4. 【寻找两个正序数组的中位数】
    给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
    请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
    你可以假设 nums1 和 nums2 不会同时为空。

    示例 1:
    nums1 = [1, 3]
    nums2 = [2]
    则中位数是 2.0

    示例 2:
    nums1 = [1, 2]
    nums2 = [3, 4]
    则中位数是 (2 + 3)/2 = 2.5
5. 【最长回文子串】 回文的意思是正着念和倒着念一样，如：上海自来水来自海上
    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

    示例 1：

    输入: "babad"
    输出: "bab"
    注意: "aba" 也是一个有效答案。
    示例 2：

    输入: "cbbd"
    输出: "bb"

18.【删除链表的节点】给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
   返回删除后的链表的头节点。
   注意：此题对比原题有改动
   示例 1:
   输入: head = [4,5,1,9], val = 5
   输出: [4,1,9]
   解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
   示例 2:
   输入: head = [4,5,1,9], val = 1
   输出: [4,5,9]
   解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
   说明：
   题目保证链表中节点的值互不相同。
   若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点。


19. 【删除链表的倒数第 N 个结点】
    输入：head = [1,2,3,4,5], n = 2
    输出：[1,2,3,5]
    示例 2：
    输入：head = [1], n = 1
    输出：[]
    示例 3：
    输入：head = [1,2], n = 1
    输出：[1]
    提示：
    链表中结点的数目为 sz
    1 <= sz <= 30
    0 <= Node.val <= 100
    1 <= n <= sz

20.【有效的括号】
    给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
    有效字符串需满足：
    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。
    示例 1：
    输入：s = "()"
    输出：true
    示例 2：
    输入：s = "()[]{}"
    输出：true
    示例 3：
    输入：s = "(]"
    输出：false
    示例 4：
    输入：s = "([)]"
    输出：false
    示例 5：
    输入：s = "{[]}"
    输出：true

21. 【合并两个有序链表】
    将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
    示例 1：
        输入：l1 = [1,2,4], l2 = [1,3,4]
        输出：[1,1,2,3,4,4]
    示例 2：
        输入：l1 = [], l2 = []
        输出：[]
    示例 3：
        输入：l1 = [], l2 = [0]
        输出：[0]
    提示：
        两个链表的节点数目范围是 [0, 50]
        -100 <= Node.val <= 100
        l1 和 l2 均按 非递减顺序 排列。

35. 【搜索插入位置】给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
    你可以假设数组中无重复元素。
    示例 1:
        输入: [1,3,5,6], 5
        输出: 2
    示例 2:
        输入: [1,3,5,6], 2
        输出: 1
    示例 3:
        输入: [1,3,5,6], 7
        输出: 4
    示例 4:
        输入: [1,3,5,6], 0
        输出: 0

53. 【最大子序和】
    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
    示例 1：
    输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
    输出：6
    解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
    示例 2：
    输入：nums = [1]
    输出：1
    示例 3：
    输入：nums = [0]
    输出：0
    示例 4：
    输入：nums = [-1]
    输出：-1
    示例 5：
    输入：nums = [-100000]
    输出：-100000
    提示：
    1 <= nums.length <= 3 * 104
    -105 <= nums[i] <= 105
    进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

116. 【填充每个节点的下一个右侧节点指针】

135. 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
     你需要按照以下要求，帮助老师给这些孩子分发糖果：
     每个孩子至少分配到 1 个糖果。
     相邻的孩子中，评分高的孩子必须获得更多的糖果。
     那么这样下来，老师至少需要准备多少颗糖果呢？

     示例 1:

     输入: [1,0,2]
     输出: 5
     解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
     示例 2:

     输入: [1,2,2]
     输出: 4
     解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
          第三个孩子只得到 1 颗糖果，这已满足上述两个条件。

167. 【两数之和 II - 输入有序数组】
    给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
    函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。
    你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 
    示例 1：
        输入：numbers = [2,7,11,15], target = 9
        输出：[1,2]
        解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
    示例 2：
        输入：numbers = [2,3,4], target = 6
        输出：[1,3]
    示例 3：
        输入：numbers = [-1,0], target = -1
        输出：[1,2]
    提示：
        2 <= numbers.length <= 3 * 104
        -1000 <= numbers[i] <= 1000
        numbers 按 递增顺序 排列
        -1000 <= target <= 1000
        仅存在一个有效答案


189. 【旋转数组】给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
    进阶：
        尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
                                                你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？
    示例 1:
        输入: nums = [1,2,3,4,5,6,7], k = 3
        输出: [5,6,7,1,2,3,4]
    解释:
        向右旋转 1 步: [7,1,2,3,4,5,6]
        向右旋转 2 步: [6,7,1,2,3,4,5]
        向右旋转 3 步: [5,6,7,1,2,3,4]
    示例 2:
        输入：nums = [-1,-100,3,99], k = 2
        输出：[3,99,-1,-100]
    解释:
        向右旋转 1 步: [99,-1,-100,3]
        向右旋转 2 步: [3,99,-1,-100]
    提示：
        1 <= nums.length <= 2 * 104
        -231 <= nums[i] <= 231 - 1
        0 <= k <= 105

206. 【反转链表】
    给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
    示例 1：
    输入：head = [1,2,3,4,5]
    输出：[5,4,3,2,1]
    示例 2：
    输入：head = [1,2]
    输出：[2,1]
    示例 3：
    输入：head = []
    输出：[]
    提示：
    链表中节点的数目范围是 [0, 5000]
    -5000 <= Node.val <= 5000
    进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？


217. 【存在重复元素】
    给定一个整数数组，判断是否存在重复元素。
    如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
    示例 1:
    输入: [1,2,3,1]
    输出: true
    示例 2:
    输入: [1,2,3,4]
    输出: false
    示例 3:
    输入: [1,1,1,3,3,4,3,2,4,2]
    输出: true



278. 【第一个错误的版本】你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
     假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
     你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
     示例 1：
         输入：n = 5, bad = 4
         输出：4
         解释：
         调用 isBadVersion(3) -> false
         调用 isBadVersion(5) -> true
         调用 isBadVersion(4) -> true
         所以，4 是第一个错误的版本。
     示例 2：
         输入：n = 1, bad = 1
         输出：1
     提示：
        1 <= bad <= n <= 231 - 1

283. 【移动零】给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
    示例:
        输入: [0,1,0,3,12]
        输出: [1,3,12,0,0]
    说明:
        必须在原数组上操作，不能拷贝额外的数组。
        尽量减少操作次数。

344. 【反转字符串】
    编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
    不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
    你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
    示例 1：
        输入：["h","e","l","l","o"]
        输出：["o","l","l","e","h"]
    示例 2：
        输入：["H","a","n","n","a","h"]
        输出：["h","a","n","n","a","H"]


442.给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。
    找到所有出现两次的元素。
    你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？
    示例：
    输入:
        [4,3,2,7,8,2,3,1]
     输出:
        [2,3]




461. 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

     给出两个整数 x 和 y，计算它们之间的汉明距离。

     注意：
     0 ≤ x, y < 231.

     示例:

     输入: x = 1, y = 4

     输出: 2

     解释:
     1   (0 0 0 1)
     4   (0 1 0 0)
            ↑   ↑

     上面的箭头指出了对应二进制位不同的位置。

557. 反转字符串中的单词 III
    给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
    示例：
        输入："Let's take LeetCode contest"
        输出："s'teL ekat edoCteeL tsetnoc"
    提示：
        在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。


560. 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

     示例 1 :

     输入:nums = [1,1,1], k = 2
     输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
     说明 :

     数组的长度为 [1, 20,000]。
     数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。

567. 【字符串的排列】
    给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
    换句话说，第一个字符串的排列之一是第二个字符串的 子串 。
    示例 1：
        输入: s1 = "ab" s2 = "eidbaooo"
        输出: True
        解释: s2 包含 s1 的排列之一 ("ba").
    示例 2：
        输入: s1= "ab" s2 = "eidboaoo"
        输出: False
    提示：
        1 <= s1.length, s2.length <= 10^4
        s1 和 s2 仅包含小写字母

617. 【合并二叉树】
    给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
    你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
    示例 1:
    输入:
        Tree 1                     Tree 2
              1                         2
             / \                       / \
            3   2                     1   3
           /                           \   \
          5                             4   7
    输出:
    合并后的树:
             3
            / \
           4   5
          / \   \
         5   4   7
    注意: 合并必须从两个树的根节点开始。


695. 【岛屿的最大面积】
    给定一个包含了一些 0 和 1 的非空二维数组 grid 。
    一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
    找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)
    示例 1:
        [[0,0,1,0,0,0,0,1,0,0,0,0,0],
         [0,0,0,0,0,0,0,1,1,1,0,0,0],
         [0,1,1,0,1,0,0,0,0,0,0,0,0],
         [0,1,0,0,1,1,0,0,1,0,1,0,0],
         [0,1,0,0,1,1,0,0,1,1,1,0,0],
         [0,0,0,0,0,0,0,0,0,0,1,0,0],
         [0,0,0,0,0,0,0,1,1,1,0,0,0],
         [0,0,0,0,0,0,0,1,1,0,0,0,0]]
        对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。
    示例 2:
        [[0,0,0,0,0,0,0,0]]
        对于上面这个给定的矩阵, 返回 0。
    注意: 给定的矩阵grid 的长度和宽度都不超过 50。


704. 【二分查找】给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
     示例 1:
         输入: nums = [-1,0,3,5,9,12], target = 9
         输出: 4
         解释: 9 出现在 nums 中并且下标为 4
     示例 2:
         输入: nums = [-1,0,3,5,9,12], target = 2
         输出: -1
         解释: 2 不存在 nums 中因此返回 -1
     提示：
         你可以假设 nums 中的所有元素是不重复的。
         n 将在 [1, 10000]之间。
         nums 的每个元素都将在 [-9999, 9999]之间。

733. 【图像渲染】
    有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
    给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
    为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，
    接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，
    重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
    最后返回经过上色渲染后的图像。
    示例 1:
    输入:
        image = [[1,1,1],[1,1,0],[1,0,1]]
        sr = 1, sc = 1, newColor = 2
    输出: [[2,2,2],[2,2,0],[2,0,1]]
    解析:
        在图像的正中间，(坐标(sr,sc)=(1,1)),
        在路径上所有符合条件的像素点的颜色都被更改成2。
        注意，右下角的像素没有更改为2，
        因为它不是在上下左右四个方向上与初始点相连的像素点。
    注意:
        image 和 image[0] 的长度在范围 [1, 50] 内。
        给出的初始点将满足 0 <= sr < image.length 和 0 <= sc < image[0].length。
        image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。


876. 【链表的中间结点】
    给定一个头结点为 head 的非空单链表，返回链表的中间结点。
    如果有两个中间结点，则返回第二个中间结点。
    示例 1：
        输入：[1,2,3,4,5]
        输出：此列表中的结点 3 (序列化形式：[3,4,5])
        返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
        注意，我们返回了一个 ListNode 类型的对象 ans，这样：
        ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
    示例 2：
        输入：[1,2,3,4,5,6]
        输出：此列表中的结点 4 (序列化形式：[4,5,6])
        由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
    提示：
        给定链表的结点数介于 1 和 100 之间。


977.【有序数组的平方】有序数组的平方
    给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
    示例 1：
        输入：nums = [-4,-1,0,3,10]
        输出：[0,1,9,16,100]
        解释：平方后，数组变为 [16,1,0,9,100]
        排序后，数组变为 [0,1,9,16,100]
    示例 2：
        输入：nums = [-7,-3,2,3,11]
        输出：[4,9,9,49,121]
    提示：
        1 <= nums.length <= 104
        -104 <= nums[i] <= 104
        nums 已按 非递减顺序 排序
    进阶：
        请你设计时间复杂度为 O(n) 的算法解决本问题。



986.

















88. 【合并两个有序数组】
    给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
    说明:
    初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
    你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
    示例:
        输入:
        nums1 = [1,2,3,0,0,0], m = 3
        nums2 = [2,5,6],       n = 3
        输出: [1,2,2,3,5,6]


 
912.【数组快速排序】
    给你一个整数数组 nums，请你将该数组升序排列。
    示例 1：
    输入：nums = [5,2,3,1]
    输出：[1,2,3,5]
    示例 2：
    输入：nums = [5,1,1,2,0,0]
    输出：[0,0,1,1,2,5]
    提示：
    1 <= nums.length <= 50000
    -50000 <= nums[i] <= 50000

















